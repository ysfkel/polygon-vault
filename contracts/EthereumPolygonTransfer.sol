//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./interfaces/IRootChainManager.sol";
import "./Fee.sol";
contract EthereumPolygonTransfer is Ownable, Fee, ReentrancyGuard{

  using SafeMath for uint256;
 
  address public erc20Token;
  address public erc20Predicate;
  address public rootChainManager;
  address feeAddress;

  event TransferInitiated(address, address, uint256);
   
  constructor(address _erc20Token, address _erc20Predicate, address _rootChainManager, address _feeAddress) {
       erc20Token = _erc20Token;
       erc20Predicate = _erc20Predicate;
       rootChainManager = _rootChainManager;
       feeAddress = _feeAddress;
  }
 
function deposit(uint256 _amount) external {
    require(IERC20(erc20Token).allowance(msg.sender, address(this))>=_amount,'INSUFFICIENT_ALLOWANCE');
    IERC20 _erc20 = IERC20(erc20Token);
    // calculate fee
    (uint256 _depositAmount , uint256 _fee) = _calculateFee(_amount);
    _erc20.transferFrom(msg.sender, address(this), _depositAmount);
    _erc20.approve(erc20Predicate, _depositAmount);
    bytes memory _encodedAmount = abi.encode(_depositAmount);
    // lock tokens and transfer to L2
    IRootChainManager(rootChainManager).depositFor(msg.sender, erc20Token, _encodedAmount);
    // send fee
    _erc20.transferFrom(msg.sender, feeAddress, _fee);
    emit TransferInitiated(msg.sender, erc20Token, _depositAmount);
  }

  /**
  Exit function on RootChainManager contract has to be called to unlock and 
  receive the tokens back from ERC20Predicate. This function takes a single bytes 
  argument that proves the burn transaction. Wait for the checkpoint containing burn 
  tenasaction to be submitted before calling this function. 
  The Proof is generated by RLP ecoding following fields -
  
  headerNumber - Checkpoint header block number containing the burn tx
  blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root
  blockNumber - Block number containing the burn tx on child chain
  blockTime - Burn tx block time
  txRoot - Transactions root of block
  receiptRoot - Receipts root of block
  receipt - Receipt of the burn transaction
  receiptProof - Merkle proof of the burn receipt
  branchMask - 32 bits denoting the path of receipt in merkle patricia tree
  receiptLogIndex - Log Index to read from the receipt
  */
  function exit(bytes calldata inputData) external{
      IRootChainManager(rootChainManager).exit(inputData);
  }

  function setERC20Predicate(address _erc20Predicate) external onlyOwner {
      require(address(_erc20Predicate) != address(0),"ERROR_ZERO_ADDRESS");
      erc20Predicate = _erc20Predicate;
  }

  function setERC20Token(address _erc20Token) external onlyOwner {
      require(address(_erc20Token) != address(0),"ERROR_ZERO_ADDRESS");
      erc20Token = _erc20Token;
  }

   function setRootChainManager(address _rootChainManager) external onlyOwner {
      require(address(_rootChainManager) != address(0),"ERROR_ZERO_ADDRESS");
      rootChainManager = _rootChainManager;
  }

}


